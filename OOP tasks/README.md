# OOP Tasks

### Task 1 Improved List
Напишите класс, который является расширением стандартного класса list. Сделайте так, чтобы, помимо обычных атрибутов в нем присутствовали такие:

reversed, который содержит тот же список, но с элементами в обратном порядке.
first, который содержит первый элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
last, который содержит последний элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
size, который содержит размер списка. Должна присутствовать возможность изменять этот атрибут: при увеличении размера в конец должны добавляться значения None, а при уменьшении последние элементы должны удаляться.

### Task 2 Customized containers
Вас попросили написать 2 класса, CustomList и CustomDict, оба эти класса имеют атрибут data, в котором хранится ссылка на список или словарь соответственно. В конструкторе класса передается список или словарь, также атрибут data можно изменять в процессе работы с классами, то есть:
```
my_list = CustomList([1, 2, 3])
my_list.data = [1, 2]
```
Оба эти класса имеют одни и те же свойства:

 - size - размер списка или словаря,
 - max_value - максимальный элемент списка или максимальный ключ словаря 
 - min_value - минимальный элемент списка или минимальный ключ словаря
и также печать экземпляров обоих классов должна возвращать строку в формате:
```
My CustomList data [1, 2, 3] (My CustomDict data {1:1, 2:2, 3:3})
```
Общие свойства и методы этих двух классов должны реализованы в классе CommonProperties, от которого 
будут
 
наследоваться
будут наследоваться классы CustomList и CustomDict.

max_value и min_value для словаря нужно считать не только по ключам, но и по значениям. В случае, если вы пытаетесь сравнить несравнимые объекты, нужно попытаться посчитать max_value и min_value только по ключам, если и это невалидно, нужно выкинуть исключение TypeError. Для этого функционала 
реализуйте
 
класс
реализуйте класс DictProperties, от которого будет наследоваться класс CustomDict.

Если же вы пытаетесь сравнить несравнимые для списка объекты (например, строки и числа), нужно выкинуть исключение TypeError.

### Task 3 Calculation of vacation
Вас попросили разработать класс, с помощью которого вычисляется размер (в рублях) оплачиваемого отпуска сотрудника за определенный период.

Нужно написать класс Vacations, со следующим функционалом:

1) метод update_salary(date, salary) - обновить зарплату, начиная с некоторой даты date. Считается, что зарплата сотрудника равна salary до тех пор, пока не существует даты date_new > date, для которой был вызван метод update_salary. Зарплата указана за один рабочий день!

Пример:
```
my_vacations = Vacations()
my_vacations.update_salary('01-01-2021', 100)
my_vacations.update_salary('01-06-2021', 500)
my_vacations.update_salary('01-01-2020', 5000)
```
Тогда зарплата сотрудника в период с 01-01-2020 по 31-12-2020 (включительно) была равна 5000, в период с 01-01-2021 по 31-05-2021 была равна 100, в период с 01-06-2021 по настоящее время зарплата сотрудника равна 500. Допускается обновление информации с более ранними датами как в примере. Также нормально, что размер заработной платы может стать меньше (кризис). Считается, что дата выхода сотрудника на работу - это минимальная дата для которой есть информация о выплатах.

2) вызов экземпляра класса должен принимать на вход две даты: дата начала отпуска и дата окончания отпуска (включительно) и возвращать размер отпускной выплаты. Отпускная выплата - это средняя зарплата в день за расчетный период (как он определяется см. ниже), умноженная на количество дней в отпуске. Считается, что сотрудник все еще работает в компании в момент, когда запрашивается информация об отпускных выплатах.

Пример:
```
my_vacations = Vacations()
my_vacations.update_salary('01-01-2021', 10000)
vacation_salary = my_vacations('01-01-2021', '01-02-2021')
```
Количество отпускных дней не ограничено. В расчет берутся данные за последние 365 дней, не включая первый день отпуска (то есть если дата начала отпуска 01-01-2021, то нужно брать данные с 01-01-2020 по 31-12-2020), при этом если сотрудник работает меньше года, берется весь период его работы. Если дата выхода сотрудника на работу больше или равна дате начала отпуска (то есть ВСЕ даты, переданные вызовам метода .update_salary к моменту вызова экземпляра класса, больше или равны дате начала отпуска), среднюю зарплату в день за расчетный период считайте равной 0 (в примере выше vacation_salary равна 0).

Теперь, мы поняли, что средняя зарплата в день за расчетный период = (общее количество заработанных денег за расчётный период) / (количество дней (считаем их все рабочими) в расчетном периоде).

Общее количество заработанных денег за расчетный период - это сумма денег, которую заработал сотрудник за последние min(365, все отработанные дни), СЧИТАЯ, ЧТО КАЖДЫЙ ДЕНЬ БЫЛ РАБОЧИМ и за него была выплачена дневная зарплата.
### Task 4 Context Manager
Вы хотите замерять время выполнения работы блока вашего кода и для этого пишите контекстный менеджер Timer (класс, который имеет методы, __enter__, __exit__). У вашего класса должно быть свойство time_spent, возвращающее время выполнения блока кода:
```
with Timer() as timer:
    your code here

print(timer.time_spent)
```
### Task 5 Context Manager - 2
Вам нужно много работать с системами линейных уравнений, в процессе решения которых часто возникает ошибка деления на ноль. Для этих нужд вы решили реализовать контекстный менеджер ZeroDivisionHandler (класс, который имеет методы __enter__, __exit__), который для заданного блока кода умеет перехватывать исключение ZeroDivisionError, печатать эту ошибку (см. пример), прерывать выполнение этого блока и продолжать работу программы.

Фактически, вместо того, чтобы много раз писать:
```
try:
    solve(a1, b1, c1)
except ZeroDivisionError as e:
    print(...)

some other code

try:
    solve(a2, b2, c2)
except ZeroDivisionError as e:
    print(...)
```
Вы решили написать класс, которым будете пользоваться следующим образом:

```
with ZeroDivisionHandler():
    solve(a1, b1, c1)

some other code

with ZeroDivisionHandler():
    solve(a2, b2, c2)
```
В качестве вывода ваша программа должна возвращать текст исключения в случае попытки деления на ноль